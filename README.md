3줄 요약
SOTA모델 AI 코딩 지원 툴들은 사용자의 지시가 불명확할 때, 개발 맥락 무시하고 부분적인 코드 작성이나 중복, 구조 외 코딩, 문법 등 개찐빠 존나 냄.
PCIP Framework는 지시 이행 과정에서 프로젝트 아키텍처와 도메인 맥락을 파악하고, 적절한 전문가(부모)를 선택해 최적의 코드 구현을 유도함.
이를 통해 사용자의 추상적인 요청도 안정적이고 일관된 코딩 결과로 연결하며, 외부 지식(RAG 또는 mcp; 툴이 지원을 해야 적용)과 실시간으로 연동해 품질을 보장. 사용법은 맨 마지막에.


🚨 Part 1: 내가 왜 이걸 만들게 됐는지 스토리



실제 겪은 참사

- 나: "성능 최적화해줘, 느려 죽겠어"

- Claude: Redis 캐싱 코드 뚝딱

- 나: "와 진짜 빨라졌네! 대박!"

- "프로필 수정해도 옛날 정보만 나와" ㅅㅂ

- 원인: 캐시 무효화 로직이 아예 없음

- 결과: 캐시 전체 초기화 ㅂㄷㅂㄷ



그때 깨달은 것:

"얘들은 코드는 잘 짜는데 '맥락'을 제대로 안짚어주면 개찐빠내는구나"





🧠 Part 2: 오은영 박사 프로그램에서 얻은 번뜩이는 영감



어느 날, 유튜브 틀어놨는데 오은영 박사 프로그램이 나옴



오은영 박사의 접근법:

- "아이한테 그냥 '게임 그만해' 하시면 안돼요"

- "먼저 아이가 왜 게임을 하는지 파악해야 해요"

- "게임을 통해 어떤 필요를 채우려고 하는 건지 이해하세요"

- "그 다음에 대안을 제시하고, 솔루션을 해주세요"



그 순간 내 머리속:

AI한테도 똑같잖아?

- 그냥 "코딩해" (X)

- 상황 파악하고, 맥락 이해하고, 가이드 해주고 (O)



AI한테도 '좋은 부모' 역할이 필요한거 아닌가?



오은영 박사님이 제시한 좋은 부모의 조건들

1. 상황 파악: "아이가 왜 이런 행동을 하는지 먼저 이해"

2. 위험 평가: "이렇게 하면 어떤 결과가 나올지 미리 생각"  

3. 맥락 고려: "우리 가정의 상황, 아이의 성격, 장기적 목표 종합 고려"

4. 가이드 제공: "단순 명령이 아닌, 이유와 함께 방향 제시"

5. 지속 관찰: "결과를 보고 지속적으로 조정"



이걸 AI 코딩에 적용하면?

1. 상황 파악: "이 요청이 어떤 종류고 얼마나 복잡한가?"

2. 위험 평가: "이 작업의 리스크는 어느 정도인가?"

3. 맥락 고려: "이 프로젝트의 특성, 기술 스택, 사용자층 고려"

4. 가이드 제공: "어떤 전문가가 어떤 관점으로 접근해야 하는가?"

5. 지속 관찰: "결과물이 기준에 맞는지 검증"





💡 Part 3: 그래서 설계한 PCIP 시스템



기존 방식의 한계

사용자 → AI → 결과물

ex) "결제 기능 만들어줘" → "네!" → 대충 만든 위험한 코드



PCIP 방식

사용자 → PM(상황판단) → Expert(전문가 멘토링) → Child(정확한 실행)

ex) "결제 기능 만들어줘" → "위험도 높음, 결제 전문가 + 보안 전문가 투입" → "PCI 규정 고려해서 이렇게 만들어" → 안전하고 완성도 높은 코드





🏗️ Part 4: 각 파트별 설계 의도 상세 분석



4-1. 3-Layer 구조가 3층인 이유

시행착오:

- 1층 (기존): 사용자 → AI → 결과물 = 맥락 무시, 품질 개판

- 2층 시도: 사용자 → Manager → 실행 = Manager가 너무 많은 일 담당, 전문성 부족

- 4층 시도: 너무 복잡해서 실용성 떨어짐, 속도 느림



3층이 최적인 이유:

- PM (Meta): 큰 그림 보고 상황 판단 (CEO 역할)

- Expert (Parent): 도메인 전문성으로 구체적 가이드 (팀장 역할)  

- Child (Execution): 가이드에 따라 정확한 실행 (실무자 역할)



4-2. PM 역할을 "15년 경험 PM"으로 구체화한 이유



초기 실패:

PM 역할: "관리자"

결과: AI가 애매하게 행동, 판단 기준 없음, 일관성 개판



개선 후:

PM 역할: "15년 경험의 프로젝트 매니저"

구체적 역할: "대화 분석, 전문가 선택, 리소스 조정"

결과: 명확한 판단 기준, 일관된 의사결정



4-3. 위험도 5단계 시스템의 과학적(?) 근거

Level 5 (Very Low) - CSS 색깔 바꾸기:

- 실제 경험: AI가 색깔 바꾸는데 보안 검토부터 시작함 ㅂㄷㅂㄷ

- 해결: 즉시 실행 (Silent Mode)



Level 1 (Critical) - 결제 시스템:

- 실제 경험: AI가 후딱 만들고 끝냄 → 보안 재앙

- 해결: 무조건 상세 계획 후 승인 (Explicit Mode)



왜 5단계? 왜 홀수?

- 3단계: 너무 대충, 구분 부정확

- 7단계: 너무 복잡, 실용성 떨어짐

- 5단계: 적당히 세분화되면서 실용적

- 홀수: 중간값 (Level 3) 존재 → 애매한 경우 처리 가능



4-4. 동적 전문가 선택 시스템

왜 미리 정해놓지 않고 실시간으로 선택?



고정 방식의 한계:

- 사용자: "쇼핑몰 만들어줘"

- 시스템: "웹 개발자 투입"

- 사용자: "아 그리고 결제도 있어야 해"

- 시스템: "어? 결제 전문가도 필요한데... 처음부터 다시?"



동적 방식의 장점:

- 사용자: "쇼핑몰 만들어줘" 

- PM: "웹 개발자 투입"

- 사용자: "결제도 있어야 해"

- PM: "알겠습니다. 결제 전문가 + 보안 전문가 추가 투입"



4-5. Silent Mode vs Explicit Mode 분리 이유

실제 사용 패턴 분석:

Silent Mode (Level 5, 4):

- 사용자: "버튼 색깔 빨간색으로 바꿔줘"

- 내 마음: "이거 간단한 거니까 빨리빨리 해줬으면..."



Explicit Mode (Level 1, 2):

- 사용자: "결제 시스템 만들어줘"  

- 내 마음: "이거 큰 일이니까 계획 좀 들어보고 싶어..."



인간의 자연스러운 기대치에 맞춤:

- 간단한 것: 빠르게

- 복잡한 것: 신중하게



4-6. 자연어 대화 학습 시스템

실제 팀장처럼:

- 팀장이 프로젝트 대화 듣고 적절한 팀원들 배치하는 것과 동일

- 자연스러운 대화로 의도 파악



4-7. External Knowledge Integration (외부 지식 통합)

실제 겪은 문제:

- 최신 Next.js 15 기능 물어봤는데 AI가 Next.js 14 기준으로 답변

- 특정 라이브러리 최신화 관련해서 틀린 정보, (shadcn)



해결책:

AI의 3단계 신뢰도 체크:

- High: 내 지식으로 충분 → 바로 답변

- Medium: 외부 자료 참조해서 검증 → 검증된 답변  

- Low: "전문 자료 찾아보겠습니다" → 정확한 정보 제공



"모르면 찾아봐" 시스템:

- 틀린 정보보다는 "잠시만요, 확인해보겠습니다"가 훨씬 나음

- 최신 정보, 정확한 규정 확인 가능



4-8. 템플릿 시스템의 필요성

템플릿 없을 때 문제:

같은 질문해도:

- 어떨 때는 코드만 던져줌

- 어떨 때는 설명만 길게

- 어떨 때는 형식이 완전 다름

→ 예측 불가능, 일관성 없음



템플릿 적용 후:

Silent Mode: 항상 [분석] → [실행] → [간단 설명] 순서

Explicit Mode: 항상 [상세 분석] → [계획] → [승인 요청] → [실행] 순서



4-9. 3중 품질 검증 시스템

검증 시스템 없을 때:

AI가 코드 만들어줌 → 나는 그냥 믿고 씀 → 나중에 문제 발견

"아 왜 이렇게 만들었지?" → 다시 수정 → 시간 낭비





3중 검증 시스템:

1. Child: 문법적 정확성, 기본 동작 확인

2. Parent: 도메인별 품질 기준 (보안, 성능, UX 등)

3. PM: 전체 프로젝트 일관성, 아키텍처 맞는지 확인





실제 효과:

- 문제 사전 발견 및 수정

- 최종 결과물 신뢰도 대폭 향상

- "이거 믿고 써도 되나?" 불안감 해소





📊 Part 5: Before & After 비교



개발 프로세스 비교



Before (기존 AI):

요청 → 빠른 구현 → 문제 발견 → 수정 → 또 문제 → 또 수정 → ...

1시간 작업이 결국 1주일로 늘어남



After (PCIP):

요청 → 분석 → 계획 → 한 번에 제대로 구현 → 완료

처음엔 좀 느리지만 전체적으로 훨씬 빠름



실제 사용 후기



장점:

- ✅ 매번 세세한 설명 안 해도 됨

- ✅ 전문가 관점이 자동으로 적용됨

- ✅ 코드 품질이 확실히 좋아짐

- ✅ 나중에 문제 생길 일이 거의 없음

- ✅ 프로젝트 일관성 유지됨



단점:

- ❌ 간단한 작업도 약간 느려짐 (그래도 Silent Mode로 최소화)

- ❌ 프롬프트가 길어서 처음엔 복잡해 보임

- ❌ 모든 상황에 완벽하지는 않음



🎯 Part 6: 실사용 팁

1. 처음엔 간단한 작업부터 → Silent Mode 체험

2. 복잡한 작업으로 점진적 확대 → Explicit Mode 체험  

3. 자연스럽게 대화하기 → "보안이 걱정돼", "성능이 중요해" 등

4. 결과물 검토하기 → AI도 완벽하지 않으니 최종 확인은 필수



사용법

아래 프롬프트를 시스템 프롬프트(인스트럭션)으로 적용하고 코딩하면 됨.

Cursor에서는 User Rules 또는 Project Rules, 영 말귀를 못알아 먹는다고 느껴지면 프롬프트에 시스템 프롬프트로 사용하라고 직접 붙여넣어 지시하면 됨.

물론, 내가 cursor 써서 예시도 Cursor.


